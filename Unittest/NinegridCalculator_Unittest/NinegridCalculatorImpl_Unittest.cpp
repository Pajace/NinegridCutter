#include "stdafx.h"
#include "CppUnitTest.h"

#ifdef WINDOWS
#include <direct.h>
#include <Windows.h>
#define GetCurrentDir _getcwd
#else
#include <unistd.h>
#define GetCurrentDir getcwd
#endif

#include <NinegridCalculatorImpl.h>
#include <string>
#include <fstream>
#include <vector>
using namespace Microsoft::VisualStudio::CppUnitTestFramework;
using namespace hTC::Image::Ninegrid;
using namespace std;

namespace NinegridCalculator_Unittest
{		


	TEST_CLASS(UnitTest1)
	{
	private:
		string testImage_10x10_ARGB_0000ff00;
		string section_b_divide_r_top_r_9;
		string testImg_Img6x5_RGB_112233;
		string testImg_Img6x5_RGB_a0a1a2;
		string testImg_Img7x6_ARGB_1e2e3e;

		string testImage1PNG;
		string testImage1RAW;
		string testImage1PNG_Without9GridInfo;

		string testImage2PNG_No9GridInfo;
		string testImage2RAW_No9GridInfo;

		
		string getCurrentFolderPath() {
			char currentDir[FILENAME_MAX];
			bool isGetCurrentDir = GetCurrentDir(currentDir, sizeof(currentDir));
			Assert::IsTrue(isGetCurrentDir);

			return string(currentDir);
		}

		bool createTestFolderAndFile(string &folderName, vector<string> &testedFiles){
			mkdir(folderName.c_str());

			ofstream outfile;
			for (size_t i=0; i<testedFiles.size(); i++){
				string filename = folderName + "\\" + testedFiles.at(i);
				outfile.open(filename, ios::out);
				if (outfile.is_open()==false) return false;
				outfile << "test" << endl;
				outfile.close();

				outfile.open(filename+".txt", ios::out);
				if (outfile.is_open()==false)  return false;
				outfile << "nonpng" << endl;
				outfile.close();
			}

			return true;
		}

		size_t calculateFileSize(string fileName) {
			size_t result = -1;
			
			ifstream infile(fileName, ios::binary | ios::ate);
			if (infile.is_open())
				result = infile.tellg();
			
			infile.close();
			return result;
		}

		void getFileBuffer(string fileName, __out BYTE **buffer) {
			ifstream in(fileName, ios::binary);
			if (in.is_open() == false) Assert::Fail(L"Open file failed");

			size_t fileSize = calculateFileSize(fileName);
			if (fileSize == -1) Assert::Fail(L"Get file size failed");

			*buffer = new BYTE[fileSize];
			in.read((char*)*buffer, fileSize);
			in.close();
		}

	public:
		TEST_METHOD_INITIALIZE(setup) {
			char workingPath[FILENAME_MAX];
			bool isGetCurrentDir = GetCurrentDir(workingPath, sizeof(workingPath));

			Assert::IsTrue(isGetCurrentDir, L"Fail to get current directory");

			testImage_10x10_ARGB_0000ff00 = string(workingPath) + "\\..\\Unittest\\NinegridCalculator_Unittest\\TestImage\\Img10X10_RGB_00ff00.png";
			testImg_Img7x6_ARGB_1e2e3e = string(workingPath) + "\\..\\Unittest\\NinegridCalculator_Unittest\\TestImage\\Img7x6_ARGB_1e2e3e.png";
			section_b_divide_r_top_r_9 = string(workingPath) + "\\..\\Unittest\\NinegridCalculator_Unittest\\TestImage\\section_b_divider_top.r.9.png";

			// 50x36 RGBA, L 10,R 10,T 21,B 3
			testImage1PNG = string(workingPath) + "\\..\\Unittest\\NinegridCalculator_Unittest\\TestImage\\TestImage1.png";
			testImage1RAW = string(workingPath) + "\\..\\Unittest\\NinegridCalculator_Unittest\\TestImage\\TestImage1.raw";
			testImage1PNG_Without9GridInfo = string(workingPath) + "\\..\\Unittest\\NinegridCalculator_Unittest\\TestImage\\TestImage1_Without9GridInfo.png";

			// 48x48 RGBA, No 9 grid infoemation
			testImage2PNG_No9GridInfo = string(workingPath) + "\\..\\Unittest\\NinegridCalculator_Unittest\\TestImage\\TestImage2.png";
			testImage2RAW_No9GridInfo = string(workingPath) + "\\..\\Unittest\\NinegridCalculator_Unittest\\TestImage\\TestImage2.raw";

		}

		TEST_METHOD_CLEANUP(tearDown){

		}

		TEST_METHOD(GetPngRawBuffer_OpenFile_Success)
		{
			char cCurrentPath[FILENAME_MAX];
			if (!GetCurrentDir(cCurrentPath, sizeof(cCurrentPath)))
				Assert::Fail(L"Fail to get working directory.");

			NinegridCalculatorImpl *ninegrid = new NinegridCalculatorImpl();
			ImageSize imageSize = {0};
			BYTE* rawBuf = NULL;

			bool isGetRawBuffer = ninegrid->GetPngRawBuffer(testImage_10x10_ARGB_0000ff00, &rawBuf, imageSize);

			Assert::IsTrue(isGetRawBuffer);


			delete rawBuf;
			delete ninegrid;
		}

		TEST_METHOD(GetPngRawBuffer_OpenFile_Fail)
		{
			NinegridCalculatorImpl *ninegrid = new NinegridCalculatorImpl();
			ImageSize imageSize = {0};
			BYTE* rawBuf = NULL;

			bool isGetRawBuffer = ninegrid->GetPngRawBuffer("NoFile.png", &rawBuf, imageSize);

			Assert::IsFalse(isGetRawBuffer);

			delete rawBuf;
			delete ninegrid;
		}

		TEST_METHOD(GetPngRawBuffer_CheckBuffer_testImg_Img7x6_ARGB_1e2e3e) {	
			BYTE EXPECTED_RAW_BUFFER[] ={ // 7x6, RRGGBBAA
				0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 
				0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 
				0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 
				0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 
				0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 
				0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 0x1e, 0x1e, 0x2e, 0x2e, 0x3e, 0x3e, 0xff, 0xff, 
			};

			const unsigned long EXPECTED_BUFFER_SIZE = sizeof(EXPECTED_RAW_BUFFER);
			const unsigned long EXPECTED_BUFFER_WIDTH = 7;
			const unsigned long EXPECTED_BUFFER_HEIGHT = 6;

			ImageSize imageSize = {0};
			BYTE* rawBuf = NULL;

			NinegridCalculatorImpl *ninegrid = new NinegridCalculatorImpl();			
			bool isGetRawBuffer = ninegrid->GetPngRawBuffer(testImg_Img7x6_ARGB_1e2e3e, &rawBuf, imageSize);
			Assert::IsTrue(isGetRawBuffer, (L"Get raw buffer failed."));			

			Assert::AreEqual(EXPECTED_BUFFER_SIZE, imageSize.dataSize);
			Assert::AreEqual(EXPECTED_BUFFER_WIDTH, imageSize.width);
			Assert::AreEqual(EXPECTED_BUFFER_HEIGHT, imageSize.heigh);

			int cmpResult = memcmp(EXPECTED_RAW_BUFFER, rawBuf, imageSize.dataSize);
			Assert::AreEqual(0, cmpResult, L"Different content of raw buffer.");

			delete rawBuf;
			delete ninegrid;
		}

		TEST_METHOD(CalculateNineGridInfo_SUCCESS) {
			NineGridInfo expectedNinegridInfo = {9, 9, 20, 2};
			NineGridInfo actualNinegridInfo = {0};

			ifstream infile(testImage1RAW, ifstream::binary);
			if ( infile.is_open() == false)
				Assert::Fail();

			infile.seekg(0, infile.end);
			size_t size = infile.tellg();
			infile.seekg(0);

			BYTE* buffer = new BYTE[size];
			infile.read((char*)buffer, size);

			ofstream outfile("test.raw", ofstream::binary);
			outfile.write((char*)buffer, size);

			ImageSize imageSize;
			imageSize.dataSize = size;
			imageSize.width = 50;
			imageSize.heigh = 36;

			NinegridCalculatorImpl *c = new NinegridCalculatorImpl();
			bool isSuccess = c->CalculateNineGridInfo(buffer, imageSize, actualNinegridInfo);

			Assert::AreEqual(expectedNinegridInfo.Left, actualNinegridInfo.Left);
			Assert::AreEqual(expectedNinegridInfo.Rright, actualNinegridInfo.Rright);
			Assert::AreEqual(expectedNinegridInfo.Top, actualNinegridInfo.Top);
			Assert::AreEqual(expectedNinegridInfo.Bottom, actualNinegridInfo.Bottom);

			delete[] buffer;
			infile.close();
			outfile.close();
			delete c;
		}

		TEST_METHOD(CalculateImageSizeWithoutNineGridInfo) {
			ImageSize expectedImageSize = {48, 34, 6528};

			ImageSize actualImageSize = {0};
			BYTE* actualRawBuffer = NULL;
			ImageSize testedSrcImageSize = {50, 36, 7200};


			ifstream infile(testImage1RAW, ifstream::binary);
			if ( infile.is_open() == false)
				Assert::Fail();

			infile.seekg(0, infile.end);
			size_t size = infile.tellg();
			infile.seekg(0);

			BYTE* testedSrcRawBuffer = new BYTE[size];
			infile.read((char*)testedSrcRawBuffer, size);

			NinegridCalculatorImpl *c = new NinegridCalculatorImpl();
			c->CalculateImageSizeWithoutNineGridInfo(testedSrcImageSize, actualImageSize);

			Assert::AreEqual(expectedImageSize.width, actualImageSize.width);
			Assert::AreEqual(expectedImageSize.heigh, actualImageSize.heigh);
			Assert::AreEqual(expectedImageSize.dataSize, actualImageSize.dataSize);

			delete [] actualRawBuffer;
			delete [] testedSrcRawBuffer;
			delete c;
		}

		TEST_METHOD(SaveImageWithout9GridInfo){
			const string SAVE_PNG_FILENAME = "TestPNG.png";

			ifstream infile(testImage1RAW, ifstream::binary);
			if ( infile.is_open() == false)
				Assert::Fail();

			infile.seekg(0, infile.end);
			size_t size = infile.tellg();
			infile.seekg(0);

			BYTE* testedSrcRawBuffer = new BYTE[size];
			infile.read((char*)testedSrcRawBuffer, size);

			ImageSize testedImageRawBufSize = {50,36,7200};
			ImageSize testedImageRawBufSizeWithout9GridInfo = {48, 34, 6528};

			NinegridCalculatorImpl *c = new NinegridCalculatorImpl();
			c->SaveImageWithout9GridInfo(SAVE_PNG_FILENAME, testedSrcRawBuffer, testedImageRawBufSize, testedImageRawBufSizeWithout9GridInfo);
			infile.close();
			delete [] testedSrcRawBuffer;

			ifstream expectedPNG(testImage1PNG_Without9GridInfo, ifstream::binary);
			ifstream actualPNG(SAVE_PNG_FILENAME, ios::binary);

			Assert::IsTrue(expectedPNG.is_open());
			Assert::IsTrue(actualPNG.is_open());

			actualPNG.seekg(0, actualPNG.end);
			expectedPNG.seekg(0, expectedPNG.end);
			size_t actualPNGSize = actualPNG.tellg();
			size_t expectedPNGSize = expectedPNG.tellg();
			actualPNG.seekg(0);
			expectedPNG.seekg(0);

			BYTE* actualPngBuffer = new BYTE[actualPNGSize];
			BYTE* expectedPngBuffer = new BYTE[expectedPNGSize];

			actualPNG.read((char*)actualPngBuffer, actualPNGSize);
			expectedPNG.read((char*)expectedPngBuffer, expectedPNGSize);

			Assert::AreEqual(expectedPNGSize, actualPNGSize);

			bool isPNGEqual = (memcmp(expectedPngBuffer, actualPngBuffer, actualPNGSize) ==0);

			Assert::IsTrue(isPNGEqual);
		}

		TEST_METHOD(GetPNGListInCurrentDir_Test){
			string testedFolderPath = getCurrentFolderPath() + "\\GetFileListInCurrentDir";
			vector<string> expectedPngFileList;
			expectedPngFileList.push_back("Test1.png");
			expectedPngFileList.push_back("Test2.png");
			expectedPngFileList.push_back("Test3.png");
			expectedPngFileList.push_back("Test4.png");
			Assert::IsTrue(createTestFolderAndFile(testedFolderPath, expectedPngFileList), L"Create tested folder and files.");

			NinegridCalculatorImpl *c = new NinegridCalculatorImpl();
			vector<string> actualPngFileList = c->GetPngFileListAtFolder(testedFolderPath+"\\*.png");

			Assert::AreEqual(expectedPngFileList.size(), actualPngFileList.size());
			for (size_t index = 0; index<expectedPngFileList.size(); index++ )
				Assert::AreEqual(expectedPngFileList.at(index), actualPngFileList.at(index));

			delete c;
		}

		TEST_METHOD(GetBaseFileName_Test) {
			NinegridCalculatorImpl *ninegrid = new NinegridCalculatorImpl();

			string tested1("ImageFile1.png");
			string tested2("ImageFile2");
			string tested3(".Imagefile3.png");
			string tested4("ImageFile4.1.2.4.png");
			string tested5(".ImageFile5");

			string expected1("ImageFile1");
			string expected2("ImageFile2");
			string expected3(".Imagefile3");
			string expected4("ImageFile4.1.2.4");
			string expected5(".ImageFile5");

			Assert::AreEqual(expected1, ninegrid->GetBaseFileName(tested1));
			Assert::AreEqual(expected2, ninegrid->GetBaseFileName(tested2));
			Assert::AreEqual(expected3, ninegrid->GetBaseFileName(tested3));
			Assert::AreEqual(expected4, ninegrid->GetBaseFileName(tested4));
			Assert::AreEqual(expected5, ninegrid->GetBaseFileName(tested5));
		}

		TEST_METHOD(SaveRawBufToPngFormat_Test) {
			// arrange
			const string ActualPNGFileName = "ActualImage.png";
			BYTE* inputRawBuffer;
			BYTE* acutalPNGBuffer;
			BYTE* expectedPNGBuffer;
			NinegridCalculatorImpl *c = new NinegridCalculatorImpl();

			this->getFileBuffer(this->testImage2RAW_No9GridInfo, &inputRawBuffer);
			size_t inputRawBufferSize = calculateFileSize(this->testImage2RAW_No9GridInfo);
			ImageSize inputRawBufferImageSize = {48, 48, 9216};
			
			this->getFileBuffer(this->testImage2PNG_No9GridInfo, &expectedPNGBuffer);
			size_t expectedPNGBufferSize = calculateFileSize(this->testImage2PNG_No9GridInfo);

			// act
			bool isSuccess = c->SaveRawBufToPngFormat(ActualPNGFileName, inputRawBuffer, inputRawBufferImageSize);
			
			// assert
			size_t acutalPNGBufferSize = calculateFileSize(ActualPNGFileName);
			this->getFileBuffer(ActualPNGFileName, &acutalPNGBuffer);

			Assert::AreEqual(expectedPNGBufferSize, acutalPNGBufferSize, L"SaveRawBufferToPNGFormat - file size error.");

			int isBufferEqual = memcmp(expectedPNGBuffer, acutalPNGBuffer, acutalPNGBufferSize);
			Assert::AreEqual(0, isBufferEqual, L"SaveRarBufToPngFormat - file content error");

			delete [] inputRawBuffer;
			delete [] expectedPNGBuffer;
			delete [] acutalPNGBuffer;
			delete c;
		}
		
		TEST_METHOD(GetSplitImgSizeByHorizontal_Test) {
		
			// Arrange
			BYTE expectedHorizontal1[] = { 
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,	0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,	0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,	 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};

			BYTE expectedHorizontal2[] = { 
				0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,	0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,	0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,	 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
				0x11, 0x12, 0x13, 0x14, 0x16, 0x16, 0x17, 0x18,	0x11, 0x12, 0x13, 0x14, 0x16, 0x16, 0x17, 0x18,	0x11, 0x12, 0x13, 0x14, 0x16, 0x16, 0x17, 0x18,	 0x11, 0x12, 0x13, 0x14, 0x16, 0x16, 0x17, 0x18,
				0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,	0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,	0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,	 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20};

			BYTE expectedHorizontal3[] = { 
				0x21, 0x21, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,	0x21, 0x21, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,	0x21, 0x21, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,	0x21, 0x21, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
				0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,	0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,	0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,	0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,	0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,	0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,	0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
				0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,	0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,	0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,	0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46 };

			BYTE inputRawBuffer [] = {
				 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
				 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
				 0x11, 0x12, 0x13, 0x14, 0x16, 0x16, 0x17, 0x18,0x11, 0x12, 0x13, 0x14, 0x16, 0x16, 0x17, 0x18,0x11, 0x12, 0x13, 0x14, 0x16, 0x16, 0x17, 0x18,0x11, 0x12, 0x13, 0x14, 0x16, 0x16, 0x17, 0x18,
				 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
				 0x21, 0x21, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,0x21, 0x21, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,0x21, 0x21, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,0x21, 0x21, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 
				 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,
				 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
				 0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, };

			NineGridInfo inputNinegridInfo = {2, 3, 1, 4};
			ImageSize inputImageSize = {8 , 8 , 64};
			

			// act
			NinegridCalculatorImpl *c = new NinegridCalculatorImpl();
			vector<BYTE*> actualHorizontalImgs = c->GetSplitRawBufferByHorizontal(inputRawBuffer, inputImageSize, inputNinegridInfo);
			vector<size_t> actualHorizontalImgsSize = c->GetSplitRawBufferSizeByHorizontal(inputImageSize, inputNinegridInfo);

			// assert1 - size
			Assert::AreEqual(sizeof(expectedHorizontal1), actualHorizontalImgsSize.at(0));
			Assert::AreEqual(sizeof(expectedHorizontal2), actualHorizontalImgsSize.at(1));
			Assert::AreEqual(sizeof(expectedHorizontal3), actualHorizontalImgsSize.at(2));

			// assert2 - buffer
			int isEqual1 = memcmp(expectedHorizontal1, actualHorizontalImgs.at(0), actualHorizontalImgsSize.at(0));
			int isEqual2 = memcmp(expectedHorizontal2, actualHorizontalImgs.at(1), actualHorizontalImgsSize.at(1));
			int isEqual3 = memcmp(expectedHorizontal3, actualHorizontalImgs.at(2), actualHorizontalImgsSize.at(2));

			Assert::IsTrue( 0 == isEqual1, L"Horizontal image1 is not equal expected." );
			Assert::IsTrue( 0 == isEqual2, L"Horizontal image2 is not equal expected." );
			Assert::IsTrue( 0 == isEqual3, L"Horizontal image3 is not equal expected." );
		}


		TEST_METHOD(GetSplitRawBufferSizeByVertical_Test) {
		
			// Arrange
			ImageSize inputImageSize = {51, 97, 19788};
			NineGridInfo inputNineGridInfo = {7, 11, 35, 24};
			size_t expectedLeftDataSize = 2716;
			size_t expectedMiddleDataSize = 12804;
			size_t expectedRightDataSize = 4268;

			// Act
			NinegridCalculatorImpl *c = new NinegridCalculatorImpl();
			vector<size_t> result = c->GetSplitRawBufferSizeByVertical(inputImageSize, inputNineGridInfo);

			// Assert
			Assert::AreEqual(expectedLeftDataSize, result.at(0), L"Left raw data size error");
			Assert::AreEqual(expectedMiddleDataSize, result.at(1), L"Middle raw data size error");
			Assert::AreEqual(expectedRightDataSize, result.at(2), L"Right raw data size error");

			delete c;		
		}

		TEST_METHOD(GetSplitRawBufferByVertical_Test){
			// Arrange

			BYTE inputRawBuffer [] = {
				 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
				 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
				 0x11, 0x12, 0x13, 0x14, 0x16, 0x16, 0x17, 0x18, 0x11, 0x12, 0x13, 0x14, 0x16, 0x16, 0x17, 0x18,0x11, 0x12, 0x13, 0x14, 0x16, 0x16, 0x17, 0x18,0x11, 0x12, 0x13, 0x14, 0x16, 0x16, 0x17, 0x18,
				 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
				 0x21, 0x21, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x21, 0x21, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,0x21, 0x21, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,0x21, 0x21, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 
				 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,
				 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
				 0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, };
						
			BYTE expectedVerticalBufferLeft[] = {
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,// 1-8
				0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,// 33-40
				0x11, 0x12, 0x13, 0x14, 0x16, 0x16, 0x17, 0x18,
				0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
				0x21, 0x21, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
				0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
				0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,
			};

			BYTE expectedVerticalBufferMiddle[] ={
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,0x01, 0x02, 0x03, 0x04, 
				0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,0x09, 0x0A, 0x0B, 0x0C, 
				0x11, 0x12, 0x13, 0x14, 0x16, 0x16, 0x17, 0x18,0x11, 0x12, 0x13, 0x14, 
				0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,0x19, 0x1A, 0x1B, 0x1C, 
				0x21, 0x21, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,0x21, 0x21, 0x23, 0x24, 
				0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,0x29, 0x2A, 0x2B, 0x2C, 
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,0x31, 0x32, 0x33, 0x34, 
				0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,0x39, 0x40, 0x41, 0x42, 
			};

			BYTE expectedVerticalBufferRight[] = {
				0x05, 0x06, 0x07, 0x08,0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
				0x0D, 0x0E, 0x0F, 0x10,0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
				0x16, 0x16, 0x17, 0x18,0x11, 0x12, 0x13, 0x14, 0x16, 0x16, 0x17, 0x18,
				0x1D, 0x1E, 0x1F, 0x20,0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
				0x25, 0x26, 0x27, 0x28,0x21, 0x21, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
				0x2D, 0x2E, 0x2F, 0x30,0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,
				0x35, 0x36, 0x37, 0x38,0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
				0x43, 0x44, 0x45, 0x46,0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,
			};

			NineGridInfo inputNinegridInfo = {2, 3, 1, 4};
			ImageSize inputImageSize = {8 , 8 , 256};

			
			// Act
			NinegridCalculatorImpl *c = new NinegridCalculatorImpl();
			vector<BYTE*> actualBuffers = c->GetSplitRawBufferByVertical(inputRawBuffer, inputImageSize, inputNinegridInfo);
			vector<size_t> actualBuffersSize = c->GetSplitRawBufferSizeByVertical(inputImageSize, inputNinegridInfo);

			// Assert
			int isLeftBufferEqual = memcmp(expectedVerticalBufferLeft, actualBuffers.at(0), actualBuffersSize.at(0));
			int isMiddleBufferEqual = memcmp(expectedVerticalBufferMiddle, actualBuffers.at(1), actualBuffersSize.at(1));
			int isRightBufferEqual = memcmp(expectedVerticalBufferRight, actualBuffers.at(2), actualBuffersSize.at(2));

			Assert::IsTrue( isLeftBufferEqual==0 , L"LeftBuffer  is not expected.l");
			Assert::IsTrue( isMiddleBufferEqual==0 , L"Middle is not expected.");
			Assert::IsTrue( isRightBufferEqual==0 , L"RightBuffer is not expected.");
		}

		TEST_METHOD(GetSplitRawBufferSizeBy9Grid_Test){
			// Arrange
			size_t expected0BufferSize = 240;
			size_t expected1BufferSize = 400;
			size_t expected2BufferSize = 640;
			size_t expected3BufferSize = 1008;
			size_t expected4BufferSize = 1680;
			size_t expected5BufferSize = 2688;
			size_t expected6BufferSize = 2928;
			size_t expected7BufferSize = 4880;
			size_t expected8BufferSize = 7808;
			ImageSize inputRawBufferImageSize = { 64, 87, 22272};
			NineGridInfo inputNinegridInfo = {12, 32, 5, 61};

			// Act
			NinegridCalculatorImpl *c = new NinegridCalculatorImpl();
			vector<size_t> actualBuffersSize = c->GetSplitRawBufferSizeBy9Grid(inputRawBufferImageSize, inputNinegridInfo);

			// Assert
			Assert::AreEqual(expected0BufferSize, actualBuffersSize.at(0), L"Top-Left buffer size error.");
			Assert::AreEqual(expected1BufferSize, actualBuffersSize.at(1), L"Top-Middle buffer size error.");
			Assert::AreEqual(expected2BufferSize, actualBuffersSize.at(2), L"Top-Right buffer size error.");
			Assert::AreEqual(expected3BufferSize, actualBuffersSize.at(3), L"Middle-Left buffer size error.");
			Assert::AreEqual(expected4BufferSize, actualBuffersSize.at(4), L"Middle-Middle buffer size error.");
			Assert::AreEqual(expected5BufferSize, actualBuffersSize.at(5), L"Middle-Right buffer size error.");
			Assert::AreEqual(expected6BufferSize, actualBuffersSize.at(6), L"Bottom-Left buffer size error.");
			Assert::AreEqual(expected7BufferSize, actualBuffersSize.at(7), L"Bottom-Middle buffer size error.");
			Assert::AreEqual(expected8BufferSize, actualBuffersSize.at(8), L"Bottom-Right buffer size error.");
		}

		TEST_METHOD(GetSplitRawBufferBy9Grid_Test) {
			// Arrange
			BYTE inputRawBuffer [] = {
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
				0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
				0x11, 0x12, 0x13, 0x14, 0x16, 0x16, 0x17, 0x18, 0x11, 0x12, 0x13, 0x14, 0x16, 0x16, 0x17, 0x18,0x11, 0x12, 0x13, 0x14, 0x16, 0x16, 0x17, 0x18,0x11, 0x12, 0x13, 0x14, 0x16, 0x16, 0x17, 0x18,
				0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
				0x21, 0x21, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x21, 0x21, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,0x21, 0x21, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,0x21, 0x21, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 
				0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
				0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, };

			BYTE expected1 [] = {
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
				0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
				0x11, 0x12, 0x13, 0x14, 0x16, 0x16, 0x17, 0x18,
				0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
			};

			BYTE expected4 [] = { 0x21, 0x21, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28 };

			BYTE expected7 [] = {
				0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
				0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,
			};

			BYTE expected2[] = {
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,0x01, 0x02, 0x03, 0x04,
				0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,0x09, 0x0A, 0x0B, 0x0C,
				0x11, 0x12, 0x13, 0x14, 0x16, 0x16, 0x17, 0x18,0x11, 0x12, 0x13, 0x14, 0x16, 0x16, 0x17, 0x18,0x11, 0x12, 0x13, 0x14,
				0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,0x19, 0x1A, 0x1B, 0x1C,
			};

			BYTE expected5[] = {
				0x21, 0x21, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,0x21, 0x21, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,0x21, 0x21, 0x23, 0x24,
			};
			BYTE expected8[] = {
				0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,0x29, 0x2A, 0x2B, 0x2C,
				0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,0x31, 0x32, 0x33, 0x34,
				0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,0x39, 0x40, 0x41, 0x42,
			};
			BYTE expected3[] = {
				0x05, 0x06, 0x07, 0x08,
				0x0D, 0x0E, 0x0F, 0x10,
				0x16, 0x16, 0x17, 0x18,
				0x1D, 0x1E, 0x1F, 0x20,
			};
			BYTE expected6[] = {
				0x25, 0x26, 0x27, 0x28,
			};
			BYTE expected9[] = {
				0x2D, 0x2E, 0x2F, 0x30,
				0x35, 0x36, 0x37, 0x38,
				0x43, 0x44, 0x45, 0x46,
			};

			NineGridInfo inputNinegridInfo = {2, 1, 4, 3};
			ImageSize inputImageSize = {8, 8, 256};

			// Act
			NinegridCalculatorImpl *c = new NinegridCalculatorImpl();
			vector<size_t> actualBuffersSize = c->GetSplitRawBufferSizeBy9Grid(inputImageSize, inputNinegridInfo);
			vector<BYTE*> actualBuffers9Grid = c->GetSplitRawBufferBy9Grid(inputRawBuffer, inputImageSize, inputNinegridInfo);

			// Assert-size
			Assert::AreEqual(sizeof(expected1), actualBuffersSize.at(0));
			Assert::AreEqual(sizeof(expected2), actualBuffersSize.at(1));
			Assert::AreEqual(sizeof(expected3), actualBuffersSize.at(2));
			Assert::AreEqual(sizeof(expected4), actualBuffersSize.at(3));
			Assert::AreEqual(sizeof(expected5), actualBuffersSize.at(4));
			Assert::AreEqual(sizeof(expected6), actualBuffersSize.at(5));
			Assert::AreEqual(sizeof(expected7), actualBuffersSize.at(6));
			Assert::AreEqual(sizeof(expected8), actualBuffersSize.at(7));
			Assert::AreEqual(sizeof(expected9), actualBuffersSize.at(8));

			// Assert buffer
			int isEqual1 = memcmp(expected1, actualBuffers9Grid.at(0), actualBuffersSize.at(0) );
			int isEqual2 = memcmp(expected2, actualBuffers9Grid.at(1), actualBuffersSize.at(1) );
			int isEqual3 = memcmp(expected3, actualBuffers9Grid.at(2), actualBuffersSize.at(2) );
			int isEqual4 = memcmp(expected4, actualBuffers9Grid.at(3), actualBuffersSize.at(3) );
			int isEqual5 = memcmp(expected5, actualBuffers9Grid.at(4), actualBuffersSize.at(4) );
			int isEqual6 = memcmp(expected6, actualBuffers9Grid.at(5), actualBuffersSize.at(5) );
			int isEqual7 = memcmp(expected7, actualBuffers9Grid.at(6), actualBuffersSize.at(6) );
			int isEqual8 = memcmp(expected8, actualBuffers9Grid.at(7), actualBuffersSize.at(7) );
			int isEqual9 = memcmp(expected9, actualBuffers9Grid.at(8), actualBuffersSize.at(8) );

			Assert::IsTrue( isEqual1==0 , L"Buffer1 is not equal");
			Assert::IsTrue( isEqual2==0 , L"Buffer2 is not equal");
			Assert::IsTrue( isEqual3==0 , L"Buffer3 is not equal");
			Assert::IsTrue( isEqual4==0 , L"Buffer4 is not equal");
			Assert::IsTrue( isEqual5==0 , L"Buffer5 is not equal");
			Assert::IsTrue( isEqual6==0 , L"Buffer6 is not equal");
			Assert::IsTrue( isEqual7==0 , L"Buffer7 is not equal");
			Assert::IsTrue( isEqual8==0 , L"Buffer8 is not equal");
			Assert::IsTrue( isEqual9==0 , L"Buffer9 is not equal");

			for (size_t i = 0; i< actualBuffers9Grid.size(); i++)
				delete [] actualBuffers9Grid.at(i);

			delete c;
		}

	};
}